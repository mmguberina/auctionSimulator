Index: mechanisms.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport pandas as pd\r\nimport gurobipy as gp\r\nfrom gurobipy import GRB\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom market_clearing import primal_multibid\r\n\r\n\"\"\"\r\ntake agent contributions and social welfare\r\nreturn payoff for each agent\r\n\r\npossibly you'll need to rerun market clearing with different participants\r\nto calculate this (certainly will have to do it for shapley)\r\n\"\"\"\r\n\r\n\r\ndef uniformPricing(agents, supply_quantities_cleared_solution, demand_quantities_cleared_solution,m):\r\n    uniform_price = m.getConstrByName(\"balance_constraint\").Pi\r\n\r\n#     sortByPrice = lambda solution : solution[1]\r\n#     supply_quantities_cleared_sorted = sorted(supply_quantities_cleared_solution, key=sortByPrice)\r\n# #    print(supply_quantities_cleared_sorted)\r\n#\r\n#     for i, solution in enumerate(supply_quantities_cleared_sorted):\r\n# #        print(solution)\r\n#         if solution[2] == 0 and i==0:\r\n#             uniform_price = 0\r\n#             break\r\n#         elif solution[2] == 0:\r\n#             uniform_price = supply_quantities_cleared_sorted[i-1][1]\r\n#             break\r\n#\r\n#     price_interval_cuttoff = 0.5\r\n#\r\n#     demand_quantities_cleared_sorted = sorted(demand_quantities_cleared_solution, key=sortByPrice)\r\n#     for i, solution in enumerate(demand_quantities_cleared_sorted):\r\n#         if solution[2] == 0 and i==0:\r\n#             break\r\n#         if solution[2] == 0:\r\n#             uniform_price = uniform_price + price_interval_cuttoff * (demand_quantities_cleared_sorted[i-1][1] - uniform_price)\r\n#             break\r\n\r\n    payoffs = [0] * len(agents)\r\n    for solution in supply_quantities_cleared_solution:\r\n#        print(solution)\r\n        payoffs[solution[3]] += uniform_price * solution[2]\r\n\r\n    for i, agent in enumerate(agents):\r\n        agent.payoff_history.append(payoffs[i])\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndef uniformPricingOld(model_grand_coalition, x_grand_coalition, bids_demand, bids_supply, \\\r\n                           date, cleared_bids_demand, cleared_bids_supply):\r\n    \"\"\"\r\n    alocate payments based on the calculated price\r\n    \"\"\"\r\n    demand = bids_demand.index.unique(0).values #set of buyer agents\r\n    supply = bids_supply.index.unique(0).values #set of seller agents\r\n\r\n    uniform_price_clearing_results = pd.DataFrame(columns=[\"unifrom_price_SEKperkW\"])\r\n    return uniform_price_clearing_results\r\n\r\n\r\n\r\ndef VCG(model_grand_coalition, x_grand_coalition, bids_demand, bids_supply, \\\r\n                date, cleared_bids_demand, cleared_bids_supply):\r\n    demand=bids_demand.index.unique(0).values #set of buyer agents\r\n    supply=bids_supply.index.unique(0).values #set of seller agents\r\n\r\n    N = np.concatenate((demand,supply)) # The players in the grand coalition\r\n\r\n    #____________________________________VCG_______________________________\r\n    SW_N = model_grand_coalition.ObjVal #the value of the grand coalition\r\n    T = list(bids_demand.groupby(level=[1]).groups.keys()) # the set of the cleared hours in a day\r\n    uniform_price_clearing_results = pd.DataFrame(columns=[\"unifrom_price_SEKperkW\"])\r\n\r\n    #reading the uniform-price from the dual variable (Pi) of the balance constraint\r\n    for t in T:\r\n        uniform_price_clearing_results.loc[t,\"unifrom_price_SEKperkW\"] = \\\r\n            model_grand_coalition.getConstrByName(\"balance_constraint[%a]\"%t).Pi\r\n\r\n\r\n    column_names = ['SW_N','SW_N\\{p}','marg_contribution','cost_or_value' ,'VCG_payment', 'uniform_price_payment']\r\n    results = pd.DataFrame(columns=column_names)\r\n\r\n    for participant in N:\r\n        bids_demand_S = bids_demand.drop(participant, errors='ignore')\r\n        bids_supply_S = bids_supply.drop(participant, errors='ignore')\r\n        #since here, only the objval is important, the dual is faster to solve than primal. however, the objval should be multiplied by -1\r\n        m,x = primal_multibid(bids_demand_S,bids_supply_S)\r\n        results.loc[participant,'SW_N\\{p}'] = m.ObjVal\r\n        results.loc[participant,'SW_N'] = SW_N\r\n        #decision of the cleared value for each participant in the grand coalition optimization\r\n\r\n        #calculating the marginal contribution of each participant\r\n        results.loc[participant,'marg_contribution'] = SW_N - results.loc[participant, 'SW_N\\{p}']\r\n\r\n        # Calculating the VCG payment:\r\n        #   the cost part of VCG payment is different for demand and supply.\\\r\n        #   So, a negative sign is multiplied to the cost part of VCG payment to supply\r\n        if participant in demand:\r\n            results.loc[participant, 'cost_or_value' ] = -(cleared_bids_demand.loc[participant,'u'] \\\r\n                                                           * cleared_bids_demand.loc[participant,'x']).sum()\r\n            results.loc[participant, 'VCG_payment'] = results.loc[participant, 'marg_contribution'] \\\r\n                                                      + results.loc[participant, 'cost_or_value' ]\r\n            # #payments in case of uniform market clearing (to compare)\r\n            results.loc[participant, 'uniform_price_payment'] \\\r\n                = -(cleared_bids_demand.loc[participant,'x'] \\\r\n                    * [uniform_price_clearing_results.loc[t,\"unifrom_price_SEKperkW\"] \\\r\n                       for t in cleared_bids_demand.loc[participant,'x'].index.get_level_values(0)]).sum()\r\n        else:\r\n            results.loc[participant, 'cost_or_value' ] = (cleared_bids_supply.loc[participant,'u'] \\\r\n                                                          * cleared_bids_supply.loc[participant,'x']).sum()\r\n            results.loc[participant, 'VCG_payment'] = results.loc[participant, 'marg_contribution'] \\\r\n                                                      - results.loc[participant, 'cost_or_value' ] * (-1)\r\n            # #payments in case of uniform market clearing (to compare)\r\n            results.loc[participant, 'uniform_price_payment'] \\\r\n                = (cleared_bids_supply.loc[participant,'x'] \\\r\n                   * [uniform_price_clearing_results.loc[t,\"unifrom_price_SEKperkW\"] \\\r\n                      for t in cleared_bids_supply.loc[participant,'x'].index.get_level_values(0)]).sum()\r\n\r\n    return results\r\n\r\n\r\ndef shapley(model_grand_coalition, x_grand_coalition, bids_demand, bids_supply, \\\r\n            date, cleared_bids_demand, cleared_bids_supply):\r\n\r\n    demand=bids_demand.index.unique(0).values #set of buyer agents\r\n    supply=bids_supply.index.unique(0).values #set of seller agents\r\n    N = np.concatenate((demand,supply)) # The players in the grand coalition\r\n\r\n    SW_N = model_grand_coalition.ObjVal #the value of the grand coalition\r\n\r\n    column_names = ['SW_N','SW_N\\{p}','marg_contribution','cost_or_value']\r\n    results = pd.DataFrame(columns=column_names)\r\n\r\n    #___________________________________Shapley______________________________\r\n\r\n    #we will divide all participants into four big groups of players as below:\r\n    players_names_in_GrandCoalition = N #The name of the big players of the game\r\n    #Find all the subsets of the grand coalition\r\n    from itertools import chain, combinations\r\n\r\n    def powerset(iterable):\r\n        \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\r\n        s = list(iterable)\r\n        return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\r\n\r\n    all_subsets = list(powerset(players_names_in_GrandCoalition))\r\n\r\n    #Calculate Shapley\r\n    from math import factorial\r\n    Shapley_value = {}\r\n    SW_S = {}\r\n    for player in players_names_in_GrandCoalition:\r\n        print(\"Player: %a\" %player)\r\n        Shapley_value [player] = 0\r\n        #iterating over all the subsets (S) of the Grand coalition\r\n        for S in all_subsets:\r\n            if player in S:\r\n                coeff = factorial(len(S)-1) * factorial(len(players_names_in_GrandCoalition) - len(S)) / factorial(len(players_names_in_GrandCoalition))\r\n                # #slicing the bids for the players\r\n                idx_slc = pd.IndexSlice\r\n                bids_demand_S = bids_demand.loc[idx_slc[list(S),:,:]]\r\n                bids_supply_S = bids_supply.loc[idx_slc[list(S),:,:]]\r\n                #calculating SW for the subset S\r\n                m_S,x_S = primal_multibid(bids_demand_S, bids_supply_S)\r\n                nu_S = m_S.ObjVal\r\n                SW_S [S] = nu_S #save the SW of each coalition to calculated the excess\r\n\r\n                #removing player from the subset S to calculate the marginal contribution\r\n                S_wo_player = list(S)\r\n                S_wo_player.remove(player)\r\n\r\n                bids_demand_S_wo_player = bids_demand.loc[idx_slc[list(S_wo_player),:,:]]\r\n                bids_supply_S_wo_player = bids_supply.loc[idx_slc[list(S_wo_player),:,:]]\r\n                m_S_wo_player, x_S_wo_player = primal_multibid(bids_demand_S_wo_player, bids_supply_S_wo_player)\r\n                nu_S_wo_player = m_S_wo_player.ObjVal\r\n\r\n                Shapley_value [player] += coeff * (nu_S - nu_S_wo_player)\r\n\r\n    #Checking if the calculation of the Shapley is correct\r\n    #Sum of Shapley values should be equal to the SW of the Grand Coalition\r\n    print('\\n---------Checking if Shapley calculations add up \\n')\r\n    print('Sum of all Shapley values: ' + str(sum(Shapley_value.values())))\r\n    print('SW in the grand coalition: ' + str(SW_N))\r\n\r\n\r\n    results_shapley = pd.DataFrame.from_dict(Shapley_value,orient='index',columns=['Shapley_value'])\r\n    #calculating the payments (r) by --> shapley values +/- the declared cost/utility\r\n    for i in players_names_in_GrandCoalition:\r\n        if i in demand:\r\n\r\n            results_shapley.loc [i, 'cost_or_utility'] = results.loc[i, 'cost_or_value']\r\n            results_shapley.loc [i, 'Shapley_payment'] \\\r\n                = results_shapley.loc [i,'Shapley_value'] \\\r\n                  + results_shapley.loc [i, 'cost_or_utility']\r\n        else: #if a seller(i.e. in \"supply\")\r\n\r\n            results_shapley.loc [i, 'cost_or_utility'] = results.loc[i, 'cost_or_value']\r\n            results_shapley.loc [i, 'Shapley_payment'] \\\r\n                = results_shapley.loc [i,'Shapley_value'] \\\r\n                  + results_shapley.loc [i, 'cost_or_utility']\r\n\r\n\r\n    print('\\n---------Checking if Shapley-based payement is budget balanced \\n')\r\n    print('Sum of Shapley payments (including cost/utility): ' + str(results_shapley['Shapley_payment'].sum()))\r\n\r\n    #Calculate and checking the stability of the grand coalition by calculating the \"excess\": e^x_S\r\n    excess_S = {}\r\n\r\n    for S in SW_S.keys():\r\n        sum_shapley_values = results_shapley.loc[[i for i in S],'Shapley_value'].sum()\r\n        excess_S[S] = SW_S[S] - sum_shapley_values\r\n\r\n    #plotting excess\r\n    excess_S_df = pd.DataFrame.from_dict(excess_S,orient='index',columns=['Excess'])\r\n    excess_S_df=excess_S_df.sort_values(by=['Excess'])\r\n    excess_S_df.plot(kind='bar')\r\n\r\n    return results, results_shapley, excess_S_df\r\n\r\n\r\n\"\"\"\r\n#----------------------------Calculating the payments-----------------------\r\ndef payment_allocation_multibid (model_grand_coalition, x_grand_coalition, bids_demand, bids_supply, \\\r\n                                 date, cleared_bids_demand, cleared_bids_supply):\r\n\r\n    # bids_demand = pd.read_excel(path_bid_demand,index_col=[0])\r\n    # bids_supply = pd.read_excel(path_bid_supply,index_col=[0])\r\n\r\n    demand=bids_demand.index.unique(0).values #set of buyer agents\r\n    supply=bids_supply.index.unique(0).values #set of seller agents\r\n\r\n    N = np.concatenate((demand,supply)) # The players in the grand coalition\r\n\r\n    #____________________________________VCG_______________________________\r\n    # model_grand_coalition, x_grand_coalition = primal_multibid(bids_demand,bids_supply)\r\n    SW_N = model_grand_coalition.ObjVal #the value of the grand coalition\r\n    T = list(bids_demand.groupby(level=[1]).groups.keys()) # the set of the cleared hours in a day\r\n    uniform_price_clearing_results = pd.DataFrame(columns=[\"unifrom_price_SEKperkW\"])\r\n\r\n    #reading the uniform-price from the dual variable (Pi) of the balance constraint\r\n    for t in T:\r\n        uniform_price_clearing_results.loc[t,\"unifrom_price_SEKperkW\"] = \\\r\n            model_grand_coalition.getConstrByName(\"balance_constraint[%a]\"%t).Pi\r\n\r\n    # models [\"Dual_GrandCoalition\"] = DualProblem(bids_demand, bids_supply)\r\n    # # dual_balance_equality = models ['Dual_GrandCoalition'] . getVarByName ( 'lambda' ).x\r\n    # uniform_price_GrandCoalition = models ['Dual_GrandCoalition'] . getVarByName ( 'lambda' ).x\r\n\r\n\r\n    column_names = ['SW_N','SW_N\\{p}','marg_contribution','cost_or_value' ,'VCG_payment', 'uniform_price_payment']\r\n    results = pd.DataFrame(columns=column_names)\r\n\r\n    for participant in N:\r\n        bids_demand_S = bids_demand.drop(participant, errors='ignore')\r\n        bids_supply_S = bids_supply.drop(participant, errors='ignore')\r\n        #since here, only the objval is important, the dual is faster to solve than primal. however, the objval should be multiplied by -1\r\n        m,x = primal_multibid(bids_demand_S,bids_supply_S)\r\n        results.loc[participant,'SW_N\\{p}'] = m.ObjVal\r\n        results.loc[participant,'SW_N'] = SW_N\r\n        #decision of the cleared value for each participant in the grand coalition optimization\r\n        # x_star_N_participant = model_grand_coalition . getVarByName ( 'x[\\''+str(participant)+'\\']' ).x\r\n        # results.loc[participant, 'x_star_N'] = x_star_N_participant\r\n        #calculating the marginal contribution of each participant\r\n        results.loc[participant,'marg_contribution'] = SW_N - results.loc[participant, 'SW_N\\{p}']\r\n\r\n        # Calculating the VCG payment:\r\n        #   the cost part of VCG payment is different for demand and supply.\\\r\n        #   So, a negative sign is multiplied to the cost part of VCG payment to supply\r\n        if participant in demand:\r\n            results.loc[participant, 'cost_or_value' ] = -(cleared_bids_demand.loc[participant,'u'] \\\r\n                                                           * cleared_bids_demand.loc[participant,'x']).sum()\r\n            results.loc[participant, 'VCG_payment'] = results.loc[participant, 'marg_contribution'] \\\r\n                                                      + results.loc[participant, 'cost_or_value' ]\r\n            # #payments in case of uniform market clearing (to compare)\r\n            results.loc[participant, 'uniform_price_payment'] \\\r\n                = -(cleared_bids_demand.loc[participant,'x'] \\\r\n                    * [uniform_price_clearing_results.loc[t,\"unifrom_price_SEKperkW\"] \\\r\n                       for t in cleared_bids_demand.loc[participant,'x'].index.get_level_values(0)]).sum()\r\n        else:\r\n            results.loc[participant, 'cost_or_value' ] = (cleared_bids_supply.loc[participant,'u'] \\\r\n                                                          * cleared_bids_supply.loc[participant,'x']).sum()\r\n            results.loc[participant, 'VCG_payment'] = results.loc[participant, 'marg_contribution'] \\\r\n                                                      - results.loc[participant, 'cost_or_value' ] * (-1)\r\n            # #payments in case of uniform market clearing (to compare)\r\n            results.loc[participant, 'uniform_price_payment'] \\\r\n                = (cleared_bids_supply.loc[participant,'x'] \\\r\n                   * [uniform_price_clearing_results.loc[t,\"unifrom_price_SEKperkW\"] \\\r\n                      for t in cleared_bids_supply.loc[participant,'x'].index.get_level_values(0)]).sum()\r\n\r\n\r\n\r\n    #checking the budget balance\r\n    budget_balance = results['VCG_payment'].sum()\r\n    print('\\n -------------Checking if VCG is budget-balanced ------------------- \\n')\r\n    print ('\\nBudget Balance:' + str(budget_balance))\r\n    if budget_balance < 0:\r\n        print('We have EXCESS in the budget!')\r\n    if budget_balance > 0:\r\n        print('We have DEFICIT in the budget!')\r\n\r\n\r\n    #___________________________________Shapley______________________________\r\n\r\n    print('\\n---------Calculating Shapley values---------\\n')\r\n\r\n    #we will divide all participants into four big groups of players as below:\r\n    players_names_in_GrandCoalition = N #The name of the big players of the game\r\n    # indexes_of_participants_under_each_player = dict.fromkeys(players_names_in_GrandCoalition)\r\n\r\n    #Find all the subsets of the grand coalition\r\n    from itertools import chain, combinations\r\n\r\n    def powerset(iterable):\r\n        \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\r\n        s = list(iterable)\r\n        return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\r\n\r\n    all_subsets = list(powerset(players_names_in_GrandCoalition))\r\n\r\n    #Calculate Shapley\r\n    from math import factorial\r\n    Shapley_value = {}\r\n    SW_S = {}\r\n    for player in players_names_in_GrandCoalition:\r\n        print(\"Player: %a\" %player)\r\n        Shapley_value [player] = 0\r\n        #iterating over all the subsets (S) of the Grand coalition\r\n        for S in all_subsets:\r\n            if player in S:\r\n                coeff = factorial(len(S)-1) * factorial(len(players_names_in_GrandCoalition) - len(S)) / factorial(len(players_names_in_GrandCoalition))\r\n                # #slicing the bids for the players\r\n                # indexes_in_S =list()\r\n                # for i in S:\r\n                #     indexes_in_S.extend(i)\r\n                idx_slc = pd.IndexSlice\r\n                bids_demand_S = bids_demand.loc[idx_slc[list(S),:,:]]\r\n                bids_supply_S = bids_supply.loc[idx_slc[list(S),:,:]]\r\n                #calculating SW for the subset S\r\n                m_S,x_S = primal_multibid(bids_demand_S, bids_supply_S)\r\n                nu_S = m_S.ObjVal\r\n                SW_S [S] = nu_S #save the SW of each coalition to calculated the excess\r\n\r\n                #removing player from the subset S to calculate the marginal contribution\r\n                S_wo_player = list(S)\r\n                S_wo_player.remove(player)\r\n\r\n                # indexes_in_S_wo_player =list()\r\n                # for i in S_wo_player:\r\n                #     indexes_in_S_wo_player.extend(i)\r\n\r\n                bids_demand_S_wo_player = bids_demand.loc[idx_slc[list(S_wo_player),:,:]]\r\n                bids_supply_S_wo_player = bids_supply.loc[idx_slc[list(S_wo_player),:,:]]\r\n                m_S_wo_player, x_S_wo_player = primal_multibid(bids_demand_S_wo_player, bids_supply_S_wo_player)\r\n                nu_S_wo_player = m_S_wo_player.ObjVal\r\n\r\n                Shapley_value [player] += coeff * (nu_S - nu_S_wo_player)\r\n\r\n    #Checking if the calculation of the Shapley is correct\r\n    #Sum of Shapley values should be equal to the SW of the Grand Coalition\r\n    print('\\n---------Checking if Shapley calculations add up \\n')\r\n    print('Sum of all Shapley values: ' + str(sum(Shapley_value.values())))\r\n    print('SW in the grand coalition: ' + str(SW_N))\r\n    #print('\\n---------------------------------------------------------')\r\n\r\n\r\n    results_shapley = pd.DataFrame.from_dict(Shapley_value,orient='index',columns=['Shapley_value'])\r\n    #calculating the payments (r) by --> shapley values +/- the declared cost/utility\r\n    for i in players_names_in_GrandCoalition:\r\n        if i in demand:\r\n\r\n            results_shapley.loc [i, 'cost_or_utility'] = results.loc[i, 'cost_or_value']\r\n            results_shapley.loc [i, 'Shapley_payment'] \\\r\n                = results_shapley.loc [i,'Shapley_value'] \\\r\n                  + results_shapley.loc [i, 'cost_or_utility']\r\n        else: #if a seller(i.e. in \"supply\")\r\n\r\n            results_shapley.loc [i, 'cost_or_utility'] = results.loc[i, 'cost_or_value']\r\n            results_shapley.loc [i, 'Shapley_payment'] \\\r\n                = results_shapley.loc [i,'Shapley_value'] \\\r\n                  + results_shapley.loc [i, 'cost_or_utility']\r\n\r\n        #bring the VCG payments for each player (just to compare with Shapley payments)\r\n        results_shapley.loc[i,'VCG_payment'] = results.loc[i,'VCG_payment']\r\n\r\n    print('\\n---------Checking if Shapley-based payement is budget balanced \\n')\r\n    print('Sum of Shapley payments (including cost/utility): ' + str(results_shapley['Shapley_payment'].sum()))\r\n\r\n    #Calculate and checking the stability of the grand coalition by calculating the \"excess\": e^x_S\r\n    excess_S = {}\r\n\r\n    for S in SW_S.keys():\r\n        sum_shapley_values = results_shapley.loc[[i for i in S],'Shapley_value'].sum()\r\n        excess_S[S] = SW_S[S] - sum_shapley_values\r\n\r\n    #plotting excess\r\n    excess_S_df = pd.DataFrame.from_dict(excess_S,orient='index',columns=['Excess'])\r\n    excess_S_df=excess_S_df.sort_values(by=['Excess'])\r\n    excess_S_df.plot(kind='bar')\r\n\r\n    return results, results_shapley, excess_S_df\r\n    \"\"\"\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mechanisms.py b/mechanisms.py
--- a/mechanisms.py	(revision 8ee1670df1611abad2d0b75a6216d22eeaa72298)
+++ b/mechanisms.py	(date 1639660293550)
@@ -3,8 +3,9 @@
 import gurobipy as gp
 from gurobipy import GRB
 import matplotlib.pyplot as plt
+import copy
 
-from market_clearing import primal_multibid
+from market_clearing import marketClearing
 
 """
 take agent contributions and social welfare
@@ -49,10 +50,26 @@
     for i, agent in enumerate(agents):
         agent.payoff_history.append(payoffs[i])
 
-
-
-
-
+def VCG_nima (agents, demand_curve, m, supply_quantities_cleared_solution):
+    SW_grand_coalition = m.ObjVal
+
+    payoffs = [0] * len(agents)
+    marg_contribution = [0] * len(agents)
+    declared_cost = [0] * len(agents)
+    for i,agent in enumerate(agents):
+        #calculating the marginal contribution to the social welfare
+        agents_without_i = copy.deepcopy(agents)
+        del agents_without_i[i]
+        _,_,m_without_i = marketClearing(agents_without_i,demand_curve)
+        marg_contribution [i] = SW_grand_coalition -  m_without_i.ObjVal
+        #to calculate the declared cost
+        filtered_solution_with_i = list(filter(lambda solution: solution[3] == i, supply_quantities_cleared_solution))
+        declared_cost [i] = sum([i_bids [1]*i_bids [2] for i_bids in filtered_solution_with_i])
+        #payoff calculation
+        payoffs [i] = marg_contribution[i] + declared_cost[i]
+
+    for i, agent in enumerate(agents):
+        agent.payoff_history.append(payoffs[i])
 
 
 
@@ -69,7 +86,7 @@
 
 
 
-def VCG(model_grand_coalition, x_grand_coalition, bids_demand, bids_supply, \
+def VCG_old(model_grand_coalition, x_grand_coalition, bids_demand, bids_supply, \
                 date, cleared_bids_demand, cleared_bids_supply):
     demand=bids_demand.index.unique(0).values #set of buyer agents
     supply=bids_supply.index.unique(0).values #set of seller agents
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport pandas as pd\r\nimport gurobipy as gp\r\nfrom gurobipy import GRB\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom agents import *\r\nfrom market_clearing import *\r\nfrom mechanisms import *\r\nfrom strategies import *\r\nfrom strategy_updating_algorithms import *\r\nfrom visualising import *\r\n\r\n# let's start with the following\r\n# 1 buyer, static demand curve\r\n# same form as bid curve\r\nif __name__ == \"__main__\":\r\n    # Create demand curve\r\n    n_of_demand_bids = 5\r\n    # only 1 buyer\r\n\r\n    demand_curve = [[5, n_of_demand_bids - i] for i in range(n_of_demand_bids)]\r\n    demand_curve[2][1] += 0.01\r\n\r\n    # Initialize agents\r\n    n_agents = 5\r\n    agents = []\r\n    for i in range(n_agents):\r\n        agents.append(Agent(\"all_the_same\"))\r\n\r\n    # Might want to move this to the runs.py file,\r\n    runs_per_strategy_update = 200   # Example for simple strategies\r\n                                    # (might need other criteria with more complex strategies)\r\n    # define termination criteria\r\n    max_epochs = 200 # Just for testing with simple termination criteria\r\n    epoch = 0\r\n    while epoch < max_epochs:\r\n        epoch += 1\r\n        # Run runs_per_strategy_update times\r\n        for i in range(runs_per_strategy_update):\r\n            for a in agents:\r\n                a.generateBid()\r\n\r\n            # Market clearing function\r\n            #supply_bids = [a.bids_curve for a in agents]\r\n            supply_quantities_cleared_solution, demand_quantities_cleared_solution,m = marketClearing(agents, demand_curve)\r\n            uniformPricing(agents, supply_quantities_cleared_solution, demand_quantities_cleared_solution,m)\r\n\r\n        # Update strategy position\r\n        PSO(agents)\r\n\r\n\r\n    #plot1AgentChanges(agents[0])\r\n    plotSupplyDemand(agents,demand_curve)\r\n    plotAgentsChanges2D(agents)\r\n    plotAgentChanges2D(agents)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 8ee1670df1611abad2d0b75a6216d22eeaa72298)
+++ b/main.py	(date 1639660293539)
@@ -11,6 +11,8 @@
 from strategy_updating_algorithms import *
 from visualising import *
 
+payment_method = "VCG"
+
 # let's start with the following
 # 1 buyer, static demand curve
 # same form as bid curve
@@ -29,10 +31,10 @@
         agents.append(Agent("all_the_same"))
 
     # Might want to move this to the runs.py file,
-    runs_per_strategy_update = 200   # Example for simple strategies
+    runs_per_strategy_update = 50   # Example for simple strategies
                                     # (might need other criteria with more complex strategies)
     # define termination criteria
-    max_epochs = 200 # Just for testing with simple termination criteria
+    max_epochs = 50 # Just for testing with simple termination criteria
     epoch = 0
     while epoch < max_epochs:
         epoch += 1
@@ -44,7 +46,10 @@
             # Market clearing function
             #supply_bids = [a.bids_curve for a in agents]
             supply_quantities_cleared_solution, demand_quantities_cleared_solution,m = marketClearing(agents, demand_curve)
-            uniformPricing(agents, supply_quantities_cleared_solution, demand_quantities_cleared_solution,m)
+            if payment_method == "uniform_pricing":
+                uniformPricing(agents, supply_quantities_cleared_solution, demand_quantities_cleared_solution,m)
+            if payment_method == "VCG":
+                VCG_nima(agents,demand_curve,m,supply_quantities_cleared_solution)
 
         # Update strategy position
         PSO(agents)
