# -*- coding: utf-8 -*-
"""
Created on Tue Jan 12 09:03:22 2021

@author: alavijeh

This is the main code, from which different functions are called
"""
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
#import district_modifier
#mport FlexProvider
import MarketOperator_SingleBid


def supply_demand_curves_plot (path_bid_buyers,path_bid_sellers):
    #Plotting
    bids_buyers = pd.read_excel(path_bid_buyers,index_col=[0])
    bids_sellers = pd.read_excel(path_bid_sellers,index_col=[0])
    
    bids_sellers_sorted = bids_sellers.sort_values(by=['u'])
    bids_buyers_sorted = bids_buyers.sort_values(by=['u'],ascending=False)
    
    # bids_sellers_sorted['k_accumulated']=np.nan
    # for s in bids_sellers_sorted.index:
    #     if s==bids_sellers_sorted.index[0]:
    #         bids_sellers_sorted.loc[s,'k_accumulated']=bids_sellers_sorted.loc[s,'k']
    #     else:
    #         bids_sellers_sorted.loc[s,'k_accumulated'] = \
    #             bids_sellers_sorted.loc[s_previous,'k_accumulated'] + bids_sellers_sorted.loc[s,'k']
    #     s_previous=s    
        
    # bids_buyers_sorted['k_accumulated']=np.nan
    # for b in bids_buyers_sorted.index:
    #     if b==bids_buyers_sorted.index[0]:
    #         bids_buyers_sorted.loc[b,'k_accumulated']=bids_buyers_sorted.loc[b,'k']
    #     else:
    #         bids_sellers_sorted.loc[s,'k_accumulated'] = \
    #             bids_buyers_sorted.loc[b_previous,'k_accumulated'] + bids_buyers_sorted.loc[b,'k']
    #     b_previous=b   
        
    
    # plt.plot(bids_sellers_sorted['k_accumulated'],bids_sellers_sorted['u'], label='Supply')  
    # plt.plot(bids_buyers_sorted['k_accumulated'], bids_buyers_sorted['u'], label='Demand')
    # #plt.hlines(bids_buyers_sorted.loc['b1','u'], 0, bids_buyers_sorted.loc['b1','k'], label='Demand', color='r')
    # plt.vlines(bids_buyers_sorted.loc['b1','k'], 0, bids_buyers_sorted.loc['b1','u'], color='gray', linestyle='dashed')
    # plt.ylim(top=bids_buyers_sorted.loc['b1','u']+2)
    # plt.xlabel('Capacity limit [kW]')
    # plt.ylabel('Price [â‚¬/kW]')
    # plt.title("Supply-Demand curve")
    # plt.legend()  
    
    # plt.savefig("supply_demand_curves.jpeg")

    for bid_idx in bids_buyers_sorted.index:
        if bids_buyers_sorted.index.get_loc(bid_idx) == 0:
            bids_buyers_sorted.loc\
                [bid_idx, "q_aggregated"]\
                    = bids_buyers_sorted.loc [bid_idx, "k"]
        else:
            bids_buyers_sorted.loc\
                [bid_idx, "q_aggregated"]\
                    = bids_buyers_sorted.iloc [bids_buyers_sorted.index.get_loc(bid_idx)-1, 3]\
                        + bids_buyers_sorted.loc [bid_idx, "k"]
    
    for bid_idx in bids_sellers_sorted.index:
        if bids_sellers_sorted.index.get_loc(bid_idx) == 0:
            bids_sellers_sorted.loc\
                [bid_idx, "q_aggregated"]\
                    = bids_sellers_sorted.loc [bid_idx, "k"]
            # plt.plot([0,bid.loc[0,'q']],[bid.loc[0,'u'],bid.loc[0,'u']])
        else:
            bids_sellers_sorted.loc\
                [bid_idx, "q_aggregated"]\
                    = bids_sellers_sorted.iloc [bids_sellers_sorted.index.get_loc(bid_idx)-1, 4]\
                        + bids_sellers_sorted.loc [bid_idx, "k"]
    
    
    #plotting the supply-demand curve
    plt.figure()
    plt.title ("Demand-supply curves")
    #adding the first point in the curves as [0,u[0]] to get the full supply/demand curves
    plt.step(np.insert(bids_buyers_sorted.q_aggregated.values,0,0), np.insert(bids_buyers_sorted.u.values,0,bids_buyers_sorted.u[0]), label="Demand",where='pre')
    plt.step(np.insert(bids_sellers_sorted.q_aggregated.values,0,0), np.insert(bids_sellers_sorted.u.values,0,bids_sellers_sorted.u[0]), label="Supply",where='pre')
    plt.xlabel("Quantity [kWh]")
    plt.ylabel("Valuation [SEK/kWh]")
    plt.legend()
##############################################################################
#----------------------------------Main--------------------------------------
##############################################################################


#_____________________calling the district_modifier______________________

#name_district='CentrumArea_Random1_Assignment1'
#GIS_data_path="Data"+"\Districts\\"+str(name_district)+".xlsx"

#district=district_modifier.district_modifier(GIS_data_path)

#___________________________Generating the bids_________________________
path_bid_buyers="bids_buyers_SingleBid.xlsx" #An assumed bid for the DSO
path_bid_sellers = "bids_sellers_SingleBid.xlsx" #Bids to be generated by FlexProvider

#FlexProvider.BidGenerator(district,path_bid_sellers)


# To check the clearing with lower number of bids:
#   1) Comment line 71 and 73
#   2) Uncomment line 80

#path_bid_sellers = "Data\Bids\\bids_sellers_simple.xlsx"

bids_buyers = pd.read_excel(path_bid_buyers,index_col=[0])
bids_sellers = pd.read_excel(path_bid_sellers,index_col=[0])

buyers=bids_buyers.index.unique(0).values #set of buyer agents
sellers=bids_sellers.index.unique(0).values #set of seller agents 

valuation_seller=1 #valuation for all the sellers

N = np.concatenate((buyers,sellers)) # The grand coalition

#____________________________________VCG_______________________________
models={}

models ['GrandCoalition'] = MarketOperator_SingleBid.PrimalProblem(bids_buyers, bids_sellers)
SW_N = models ['GrandCoalition'].ObjVal

models ["Dual_GrandCoalition"] = MarketOperator_SingleBid.DualProblem(bids_buyers, bids_sellers)
# dual_balance_equality = models ['Dual_GrandCoalition'] . getVarByName ( 'lambda' ).x
uniform_price_GrandCoalition = models ['Dual_GrandCoalition'] . getVarByName ( 'lambda' ).x


column_names = ['SW_N\{p}','marg_contribution', 'x_star_N','VCG_payment', 'profit_VCG', 'uniform_price_payment', 'profit_price_payment']
results = pd.DataFrame(columns=column_names)

for participant in N:
    bids_buyers_S = bids_buyers.drop(participant, errors='ignore')
    bids_sellers_S = bids_sellers.drop(participant, errors='ignore')
    #since here, only the objval is important, the dual is faster to solve than primal. however, the objval should be multiplied by -1
    m = MarketOperator_SingleBid.DualProblem(bids_buyers_S, bids_sellers_S) 
    results.loc[participant,'SW_N\{p}'] = -1 * m.ObjVal
    #decision of the cleared value for each participant in the grand coalition optimization  
    x_star_N_participant = models ['GrandCoalition'] . getVarByName ( 'x[\''+str(participant)+'\']' ).x
    results.loc[participant, 'x_star_N'] = x_star_N_participant
    #calculating the marginal contribution of each participant
    results.loc[participant,'marg_contribution'] = SW_N - results.loc[participant, 'SW_N\{p}']
    # Calculating the VCG payment:
    #   the cost part of VCG payment is different for buyers and sellers.\
    #   So, a negative sign is multiplied to the cost part of VCG payment to sellers
    if participant in buyers:
        results.loc[participant, 'VCG_payment'] = results.loc[participant, 'marg_contribution'] \
            - results.loc[participant, 'x_star_N'] * bids_buyers.loc[participant, 'u']
        #payments in case of uniform market clearing (to compare)
        results.loc[participant, 'uniform_price_payment'] \
            = -1 * results.loc[participant, 'x_star_N'] * uniform_price_GrandCoalition
    else:
        results.loc[participant, 'VCG_payment'] = results.loc[participant, 'marg_contribution'] \
            - results.loc[participant, 'x_star_N'] * bids_sellers.loc[participant, 'u'] * (-1)
        results.loc[participant, 'profit_VCG'] = results.loc[participant, 'VCG_payment'] \
            - (results.loc[participant, 'x_star_N'] * valuation_seller)
        #payments in case of uniform market clearing (to compare)
        results.loc[participant, 'uniform_price_payment'] \
            = results.loc[participant, 'x_star_N'] * uniform_price_GrandCoalition
        results.loc[participant, 'profit_price_payment'] \
            = ( uniform_price_GrandCoalition - valuation_seller)  * results.loc[participant, 'x_star_N']
            


#budget balance
budget_balance = results['VCG_payment'].sum()
print('\n -------------Checking if VCG is budget-balanced ------------------- \n')
print ('\nBudget Balance:' + str(budget_balance))
if budget_balance < 0:
    print('We have EXCESS in the budget!')
if budget_balance > 0:
    print('We have DEFICIT in the budget!')
    
print("Social Welfare:%a" %SW_N)
    
"""
#___________________________________Shapley______________________________

#we will divide all participants into four big groups of players as below:
players_names_in_GrandCoalition = ['serv','hus','lgh','buyer'] #The name of the big players of the game
indexes_of_participants_under_each_player = dict.fromkeys(players_names_in_GrandCoalition)

#defining who will be under which player
for player in players_names_in_GrandCoalition:
    if player == 'buyer':
        indexes_of_participants_under_each_player [player] = list(bids_buyers.index.values)
    else:
        indexes_of_participants_under_each_player [player] \
            = list(bids_sellers.loc[bids_sellers['usage_type']==player].index.values)


#Find all the subsets
from itertools import chain, combinations

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

all_subsets = list(powerset(players_names_in_GrandCoalition))

#Calculate Shapley
from math import factorial
Shapley_value = {}
SW_S = {}
for player in players_names_in_GrandCoalition:
    Shapley_value [player] = 0
    for S in all_subsets:
        if player in S:
            coeff = factorial(len(S)-1) * factorial(len(players_names_in_GrandCoalition) - len(S)) / factorial(len(players_names_in_GrandCoalition))
            #slicing the bids for the players
            indexes_in_S =list()
            for i in S:
                indexes_in_S.extend(indexes_of_participants_under_each_player[i])

            bids_buyers_S = bids_buyers.drop(index=bids_buyers.index.difference(indexes_in_S),errors='ignore')
            bids_sellers_S = bids_sellers.drop(index=bids_sellers.index.difference(indexes_in_S),errors='ignore')
            
            nu_S = -1 * MarketOperator_SingleBid.DualProblem(bids_buyers_S, bids_sellers_S).ObjVal
            SW_S [S] = nu_S #save the SW of each coalition to calculated the excess
            
            #removing player from set S to calculate the marginal contribution
            S_wo_player = list(S)
            S_wo_player.remove(player)
            
            indexes_in_S_wo_player =list()
            for i in S_wo_player:
                indexes_in_S_wo_player.extend(indexes_of_participants_under_each_player[i])

            bids_buyers_S_wo_player = bids_buyers.drop(index=bids_buyers.index.difference(indexes_in_S_wo_player),errors='ignore')
            bids_sellers_S_wo_player = bids_sellers.drop(index=bids_sellers.index.difference(indexes_in_S_wo_player),errors='ignore')
            nu_S_wo_player = -1 * MarketOperator_SingleBid.DualProblem(bids_buyers_S_wo_player, bids_sellers_S_wo_player).ObjVal
            
            
            Shapley_value [player] += coeff * (nu_S - nu_S_wo_player)
 
#Checking if the calculation of the Shapley is correct
#Sum of Shapley values should be equal to the SW of the Grand Coalition
print('\n---------Checking if Shapley calculations add up---------\n')
print('Sum of all Shapley values: ' + str(sum(Shapley_value.values())))
print('SW in the grand coalition: ' + str(SW_N))
#print('\n---------------------------------------------------------')


results_shapley = pd.DataFrame.from_dict(Shapley_value,orient='index',columns=['Shapley_value'])
#calculating the payments (r) by adding x(shapley values) +- cost
for i in players_names_in_GrandCoalition:
    if i=='buyer':
        #summing all the utlity in the buyer group
        cost_or_utility = results.loc[indexes_of_participants_under_each_player[i],'x_star_N'] \
            * bids_buyers.loc[indexes_of_participants_under_each_player[i],'u']
            
        sum_cost_or_utility = (-1) * cost_or_utility.sum()  #buyer have to pay, so negative  
        
        results_shapley.loc [i, 'cost_or_utility'] = sum_cost_or_utility
        results_shapley.loc [i, 'Shapley_payment'] \
            = results_shapley.loc [i,'Shapley_value'] \
                + sum_cost_or_utility
    else:
        #summing all the utlity in the buyer group
        cost_or_utility = results.loc[indexes_of_participants_under_each_player[i],'x_star_N'] \
            * bids_sellers.loc[indexes_of_participants_under_each_player[i],'u']
        sum_cost_or_utility = cost_or_utility.sum()   
        
        results_shapley.loc [i, 'cost_or_utility'] = sum_cost_or_utility
        
        results_shapley.loc [i, 'Shapley_payment'] \
            = results_shapley.loc [i,'Shapley_value'] \
                + sum_cost_or_utility
                
    #bring the VCG payments for each Big player (just to compare with Shapley payments)
    results_shapley.loc[i,'VCG_payment'] \
        = results.loc[indexes_of_participants_under_each_player[i],'VCG_payment'].sum()
    #bring the uniform pricing payments for each Big player (just to compare)
    results_shapley.loc[i,'uniform_price_payment'] \
        = results.loc[indexes_of_participants_under_each_player[i],'uniform_price_payment'].sum()    
                
print('\n---------Checking if Shapley-based payement is budget balanced---------\n')
print('Sum of Shapley payments (including cost/utility): ' + str(results_shapley['Shapley_payment'].sum()))

#Calculate and checking the "excess": e^x_S
excess_S = {}

for S in SW_S.keys():
    sum_shapley_values = results_shapley.loc[[i for i in S],'Shapley_value'].sum()
    excess_S[S] = SW_S[S] - sum_shapley_values

#plotting excess
excess_S_df = pd.DataFrame.from_dict(excess_S,orient='index',columns=['Excess'])
excess_S_df=excess_S_df.sort_values(by=['Excess'])
excess_S_df.plot(kind='bar')
"""
supply_demand_curves_plot (path_bid_buyers,path_bid_sellers) 
 



          

